1)what is Inheritance?
-> Inheritance is simply one class inherit the method and properties of another class. 
  the parent class it self called base class and the child class which inherit the properties and method of parent class is called derived class.
there is 5 types of inhertiance.
i) single inheritance - it have one parent class and one child class.
ii) muti-level inheritance - it have one grandparent class, one parent class and one child class.
iii) multiple inheritance - it have more than 1 parent class and one child.
iv) hyrachical inheritance - it have one parent class and mutiple/more than 1 child class.
v) hybrid inheritance - it mixture of all inheritance.


2)what is Abstaction?
-> Abstraction is process of handling complexities by hiding unnecessary information from user and only expose the desired information to user.
for this here example. we have to import the abc module - from abc (abstract base classes) import ABC (Abstract Base Class) and abstractmethod
eg.
  from abc import ABC, abstractmethod

  class shape(ABC):
    def area(self):
      pass

  class circle(shape):
    def __init__(self,value1):
      self.val1= value1

    def area(self):
      return 3.14 * self.val1 * self.val1

  circle = circle(5)
  print(cirle.area())

3) what is Encapsulation?
-> Encapsulation is method to bind the method and data(attribute) in single unit which known as class. it helps to stop/restrict the direct access to object component and prevent the modifications.
    we have to use double underscore (__) to make private variable/attribute. this is can't be accessible nor changeable outside this class but we can access it inside class only
    single underscore (_) use for protected. this is can be accessible but we must not access it.
eg.
  class Car:
    def __init__(self, brand, mileage):
        self.__brand = brand  # double underscore to private attribute

    def get_brand(self):
        return self.__brand

    def set_brand(self, brand):
        self.__brand = brand

    def display_info(self):
        print(f"Brand: {self.__brand}")

  car1 = Car("Toyota", 30) # Create an object of the Car class

print(car1.get_brand())  # Output: Toyota # Accessing attributes using getter methods

# Modifying attributes using setter methods -> set_ is meaningless just normal name for understand it use to set value
car1.set_brand('Nissan')
car1.display_info()  # Output: Brand: Toyota

#another cases
i) # print(car1.__brand)  # This will definetly give an AttributeError because it not available in Car class it have self.__brand (car1.self.__brand) but can't access like this
car1.__brand = 'Honda' # this is accidental modification from outside class but it not modify the data it create new namespace/attribute

ii) car1._Car__brand = 'Nissian' # Accessing attributes directly (not recommended for private attributes) It bypass encapsulation it can create bug or not proper.


4) what is Polymorphism?
-> Poly mean many and morph mean form. it is good for reusablility and have flexibility.
eg. the flow is like we pass argument the object/variable dog into function animal_speak() it get the dog class access due in function animal_speak we are printing animal.speak() it look into dog class for
    method speak which is present so it return the control back and you see the output (maybe like this happen).

 eg. class Animal: # this is just blueprint
      def __init__(self, name):
          self.name = name
  
      def speak(self):
          raise NotImplementedError("Subclass must implement abstract method")
  
  class Dog(Animal):
      def speak(self):
          return f"{self.name} says Woof!"
  
  class Cat(Animal):
      def speak(self):
          return f"{self.name} says Meow!"
  
  def animal_speak(animal): # Function that show polymorphism, this is important
      print(animal.speak())
  
  # Creating instances/object of different classes
  dog = Dog("Buddy")
  cat = Cat("Whiskers")
  
  # Calling the function with different objects
  animal_speak(dog)  # Output: Buddy says Woof!
  animal_speak(cat)  # Output: Whiskers says Meow!


5) what are decorators?
-> Decorators are a very powerful and useful tool in Python since it allows programmers to modify the behaviour of a function or class.
eg.
  class Circle:
    def __init__(self, radius):
        self._radius = radius

    #@property is built-in decorator so use can use direct
    @property # use to make any method/function behave like attribute/varibale that can be accessible without ()
    def diameter(self):
        return self._radius * 2

    @diameter.setter # using @diameter is property and .setter use to make only we can change not for get. eg. @property.setter
    def diameter(self, value):
        self._radius = value / 2

  circle = Circle(5)
  
  # Accessing the property -> also work as .getter
  print(circle.diameter)  # Output: 10
  # if diameter wasn't property we have to access it like print(circle.diameter()) # it have behaivour make it attribute instead method.

  # Setting the property using the setter method. due to we earlier change diameter method into property we can directly set the value
  circle.diameter = 12
  print(circle.diameter)  # Output: 12 (diameter is now 12, radius is 6)

  # if we haven't set as property we have to set like circle.diameter(12)
---------------------------


